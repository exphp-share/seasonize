#include "ECLinclude/ECLplus.tecl"
#include "seasons-data.tecl"
#include "keys.tecl"

anim { "seasons.anm"; }

int ClipInt(int x, int a, int b) {
    if (x < a) { return a; }
    else if (x > b) { return b; }
    else { return x; }
}

int CurrentSeason() { return $GI4; }
int CurrentSeasonPower() { return $GI5; }
int ReleaseInCooldown() { return $GI6; }
int DebuggerGlobal() { return $GI7; }
void SetCurrentSeason(int season) { $GI4 = season; return; }
void SetCurrentSeasonPower(int power) { $GI5 = ClipInt(power, 0, MAX_SEASON_POWER); return; }
void SetReleaseInCooldown(int b) { $GI6 = b; return; }
void SetDebuggerGlobal(int value) { $GI7 = value; return; }

global SMENU_BG_ANM_SCRIPT = 2 * NUM_SEASONS;  // season menu
global SMENU_FG_ANM_SCRIPT = 2 * NUM_SEASONS + 1;  // season menu boom
global SMENU_ICON_ANM_SCRIPT = 2 * NUM_SEASONS + 2;  // season menu icon
global SG_FIRST_ANM_SCRIPT = 2 * NUM_SEASONS + 3; // season gauge

// TODO: Correct damage amounts
//    - compare scaling of HP in HSiFS vs WBaWC
// TODO: Fall release effect on player speed
// TODO: Winter release effect on attack power
// TODO: Season items on enemy kill
// TODO: Season items on damage dealt
// TODO: Season items from release bullet cancels (tricky) (important!)
// TODO: Season items from bomb bullet cancels (tricky)
// TODO: Fix text alignments and fonts
// TODO: Better menu
//   - thought: 5 icons around player
//   - thought: have selected icon fly over to gauge, then gauge appears.
//     (tricky due to different coord systems)
// TODO: (MAYBE) allow disabling beast items (fish and specials only)
// TODO: Fix gauge positioning w.r.t. beast items

int BitNot(int x) {
    return 0xFFFFFFFF - x;
}

void SeasonMenuEnemy() {
    flagSet(1); // no hurtbox
    flagSet(2); // no hitbox
    flagSet(128); // not killed by dialogRead or enmKillAll
    flagSet(12); // don't delete beyond screen edges

    enmCreate("SeasonGaugeEnemy", 0f, 0f, 1, 0, 0);

    playerAllowShot(false);
    playerAllowBomb(false);

    SetCurrentSeason(SPRING);
    SetCurrentSeasonPower(0);
    SetReleaseInCooldown(0);

    anmSelect(4);
    anmSetSprite(0, SMENU_BG_ANM_SCRIPT);
    anmScale(0, 700f, 700f);

    // We'll be using our own channel to tell the children when to stop.
    // Tell them our ID by setting their life.
    msgReset(ID);
    enmCreate("SeasonMenuIconEnemy0", 0f, 0f, ID, 0, 0);
    enmCreate("SeasonMenuIconEnemy1", 0f, 0f, ID, 0, 0);
    enmCreate("SeasonMenuIconEnemy2", 0f, 0f, ID, 0, 0);
    enmCreate("SeasonMenuIconEnemy3", 0f, 0f, ID, 0, 0);
    enmCreate("SeasonMenuIconEnemy4", 0f, 0f, ID, 0, 0);

    int oldInput = $INPUT;
    int oldSeason = -1; // ensure background change on first frame
    int shouldEnd = 0;

    while(true) {
        int risingEdge = $INPUT & BitNot(oldInput);
        int season = CurrentSeason();

        movePos(PLAYER_X, PLAYER_Y);

        if (risingEdge & KEY_SHOT) {
            playSound(10); // menu bwap
            season += 1;
            season %= NUM_SEASONS;
            SetCurrentSeason(season);
        }

        if (risingEdge & KEY_SKIP) {
            playSound(74); // release PLING!!
            shouldEnd = 1;
        }

        // if-else chain to ensure only one anmSwitch per frame.
        if (oldSeason != season) {
            anmSwitch(0, 1 + season); // change background color
            oldSeason = season;
        } else if (shouldEnd) {
            // Begin special FX
            anmSetSprite(1, SMENU_FG_ANM_SCRIPT); // create vortex
            anmSwitch(0, 7); // make background get sucked in
            playSound(30); // charge sound
            msgSend(0f, 0f, 0f, 0f, ID); // tell the icons to disappear

            // Enable player capabilities
            playerAllowShot(true);
            playerAllowBomb(true);
            enmCreate("SeasonInputEnemy", 0f, 0f, 1, 0, 0);

            // Wait for anim to play out
            times(90) {
                movePos(PLAYER_X, PLAYER_Y);
                wait(1);
            }

            // camera KERCHONK
            playSound(31);
            delete();
        }
        drawColor(0xFFFFFF00);
        drawAnchor(0, 0);
        drawf(0f, 224f, "SHOT: Change season");
        drawf(0f, 224f+12f, "SKIP: Confirm");
        drawColor(0xFFFFFFFF);
        oldInput = INPUT;
        wait(1);
    }
}

void SeasonMenuIconEnemy0() { @SeasonMenuIconEnemy(0); }
void SeasonMenuIconEnemy1() { @SeasonMenuIconEnemy(1); }
void SeasonMenuIconEnemy2() { @SeasonMenuIconEnemy(2); }
void SeasonMenuIconEnemy3() { @SeasonMenuIconEnemy(3); }
void SeasonMenuIconEnemy4() { @SeasonMenuIconEnemy(4); }

global DIRECTION_UP = 4.71238898038;
global TAU_OVER_FIVE = 1.25663706144;
global SMENU_ICON_RADIUS = 50f;
global SMENU_ICON_ALPHA_ACTIVE = 255;
global SMENU_ICON_ALPHA_INACTIVE = 128;
global SMENU_ICON_SCALE_ACTIVE = 1f;
global SMENU_ICON_SCALE_INACTIVE = 0.75f;
void SeasonMenuIconEnemy(int mySeason) {
    flagSet(1); // no hurtbox
    flagSet(2); // no hitbox
    flagSet(128); // not killed by dialogRead or enmKillAll
    flagSet(12); // don't delete beyond screen edges

    anmSelect(4);
    anmSetSprite(0, SMENU_ICON_ANM_SCRIPT);
    anmSwitch(0, 100 + mySeason);

    // The parent told us its ID by setting our life.
    // Use that channel for communication.
    int parent = LIFE;

    // If the player keeps changing the season, we will keep letting the angle
    // increase in magnitude; this way, things never appear to move backwards.
    //
    // Technically, this will accumulate roundoff error over time, but the player
    // is not going to be changing season enough times for it to become noticeable.
    int curSeason = CurrentSeason();
    float targetAngle = DIRECTION_UP + TAU_OVER_FIVE * _f((mySeason - curSeason) % 5);
    F0 = targetAngle;

    if (curSeason == mySeason) {
        anmAlpha(0, SMENU_ICON_ALPHA_ACTIVE);
        anmScale(0, SMENU_ICON_SCALE_ACTIVE, SMENU_ICON_SCALE_ACTIVE);
    } else {
        anmAlpha(0, SMENU_ICON_ALPHA_INACTIVE);
        anmScale(0, SMENU_ICON_SCALE_INACTIVE, SMENU_ICON_SCALE_INACTIVE);
    }

    int oldSeason = curSeason;
    int received = 0;
    while(!received) {
        curSeason = CurrentSeason();

        if (oldSeason != curSeason) {
            if (oldSeason == mySeason) {
                anmAlphaTime(0, 7, 4, SMENU_ICON_ALPHA_INACTIVE);
                anmScaleTime(0, 7, 4, SMENU_ICON_SCALE_INACTIVE, SMENU_ICON_SCALE_INACTIVE);
            } else if (curSeason == mySeason) {
                anmAlphaTime(0, 7, 4, SMENU_ICON_ALPHA_ACTIVE);
                anmScaleTime(0, 7, 4, SMENU_ICON_SCALE_ACTIVE, SMENU_ICON_SCALE_ACTIVE);
            }

            if ((oldSeason + 1) % 5 == curSeason) {
                targetAngle -= TAU_OVER_FIVE; // CCW
            } else if (oldSeason == (curSeason + 1) % 5) {
                targetAngle += TAU_OVER_FIVE; // CW
            } else {
                printf("season changed impossibly fast!\n");
            }

            floatTime(0, F0, 7 /* time */, 4 /* mode */, F0, targetAngle);
            oldSeason = curSeason;
        }

        movePos(PLAYER_X, PLAYER_Y);
        moveCircleRel(F0, 0f, SMENU_ICON_RADIUS, 0f);

        wait(1);
        // stop once we hear from the parent
        msgCheck(received, parent);
    }

    // Disappear into player
    anmAlphaTime(0, 15, 0, 0);
    floatTime(1, F1, 15, 0, SMENU_ICON_RADIUS, 0f);
    times(15) {
        moveCircleRel(F0, 0f, F1, 0f);
        wait(1);
    }
    delete();
}

void SeasonInputEnemy() {
    flagSet(32); // intangible

    int oldInput = $INPUT;
    int releaseId = 0;

    enmCreate("SeasonDebugGlobalsEnemy", 0f, 0f, 1, 0, 0);

    SetCurrentSeasonPower(98);
    SetReleaseInCooldown(0);

    while(true) {
        int risingEdge = $INPUT & BitNot(oldInput);
        if (risingEdge & KEY_SKIP) {
            if (!ReleaseInCooldown()) {

                // if ($INPUT & KEY_SLOW) {
                //     printf("Old Season Release!!\n");
                //     enmCreate("SeasonReleaseEnemy", %PLAYER_X, %PLAYER_Y, 1, 0, 0);
                //     releaseId = LAST_ENM_ID;
                // } else {
                    printf("New Season Release!!\n");
                    enmCreate("SeasonReleaseEnemy", %PLAYER_X, %PLAYER_Y, 1, 0, 0);
                    releaseId = LAST_ENM_ID;
                // }
            }
        }
        oldInput = $INPUT;
        wait(1);
    }
    return;
}

// ========================================

global SG_SLOT__BOX = 0;
global SG_SLOT__FILL_FG = 1;
global SG_SLOT__FILL_BG = 2;
global SG_SLOT__SEASON_NAME = 3;
global SG_SLOT__RELEASABLE = 4;
global SG_NUM_ANM_SCRIPTS = 5;

// General events that all season gauge anm scripts listen for.
global SG_EVENT__DISAPPEAR = 1;
global SG_EVENT__PLAYER_FAR = 4;
global SG_EVENT__PLAYER_NEAR = 5;
// Originally in TH16, most sprites of the season gauge listened for
// events 2 (level becomes >= 1) and 3 (level becomes 0).
// However, one of them instead listened to events 8-13 (level became value 1-6).
//
// We've modified the scripts so that all listen to 7-13 for levels 0-6.
global SG_EVENT__SET_LEVEL_0 = 7;

void SeasonGaugeEnemy__Event(int event) {
    int slot = 0;
    times(SG_NUM_ANM_SCRIPTS) {
        anmSwitch(slot, event);
        slot += 1;
    }
    return;
}

void SeasonGaugeEnemy__SetSeason(int season) {
    anmSwitch(SG_SLOT__SEASON_NAME, 100 + season);
    return;
}

void SeasonGaugeEnemy() {
    flagSet(1); // no hurtbox
    flagSet(2); // no hitbox
    flagSet(128); // not killed by dialogRead or enmKillAll

    anmSelect(4);

    int slot = 0;
    times(SG_NUM_ANM_SCRIPTS) {
        anmSetSprite(slot, SG_FIRST_ANM_SCRIPT + slot);
        slot += 1;
    }

    int wasPlayerNear = 0;
    int oldSeason = -1;
    int oldLevel = -1;
    int oldPower = CurrentSeasonPower();

    while(true) {
        int season = CurrentSeason();
        int power = CurrentSeasonPower();
        int level = SeasonLevel(power);

        // check for events.  We can only send one event per frame, so we use an if-else chain
        // to hold off on updating more than one thing. (checking things in decreasing order
        // of urgency)
        if (season != oldSeason) {
            // set the season, and hold off on events because we can't use anmSwitch more than
            // once on the same object in a single frame
            SeasonGaugeEnemy__SetSeason(season);
            oldSeason = season;

        } else if (level != oldLevel) {
            SeasonGaugeEnemy__Event(SG_EVENT__SET_LEVEL_0 + level);
            oldLevel = level;

        } else if (!wasPlayerNear && ((%PLAYER_X < SG_PLAYER_NEAR_X) && (%PLAYER_Y > SG_PLAYER_NEAR_Y))) {
            SeasonGaugeEnemy__Event(SG_EVENT__PLAYER_NEAR);
            wasPlayerNear = true;
        } else if (wasPlayerNear && !((%PLAYER_X < SG_PLAYER_FAR_X) && (%PLAYER_Y > SG_PLAYER_FAR_Y))) {
            SeasonGaugeEnemy__Event(SG_EVENT__PLAYER_FAR);
            wasPlayerNear = false;
        }

        int gaugeData = SeasonGaugeData(level);
        int gaugeStart = gaugeData % 0x1000;
        int gaugeEnd = gaugeData / 0x1000;
        float ratio = _f(power - gaugeStart) / _f(gaugeEnd - gaugeStart);
        anmScale(SG_SLOT__FILL_FG, ratio, 1f);
        anmScale(SG_SLOT__FILL_BG, _f(level > 0), 1f);

        drawColor(SeasonLevelNumberColor(level));
        // TODO: set font to 2
        // TODO: set alignment to 2, 0
        drawFont(2);
        drawAnchor(2, 0);
        drawf(-132f, 446f-16f, "%d", _SS level);
        drawReset();
        wait(1);
    }
    return;
}

void SeasonDebugGlobalsEnemy() {
    flagSet(32); // intangible

    while(true) {
        drawf(-224f, 0f, "G4: %d", _SS $GI4);
        drawf(-224f, 12f, "G5: %d", _SS $GI5);
        drawf(-224f, 24f, "G6: %d", _SS $GI6);
        drawf(-224f, 36f, "G7: %d", _SS $GI7);
        wait(1);
    }
    return;
}

// ========================================

void SeasonDebugMenuEnemy() {
    flagSet(32); // intangible

    playerAllowShot(false);
    playerAllowBomb(false);

    SetCurrentSeasonPower(0);

    int oldInput = 0;
    while(true) {
        int risingEdge = $INPUT & BitNot(oldInput);
        if (risingEdge & KEY_BOMB) {
            SetCurrentSeason((CurrentSeason() + 1) % NUM_SEASONS);
        }
        if (risingEdge & KEY_SHOT) {
            if ($INPUT & KEY_SLOW) {
                int level = SeasonLevel(CurrentSeasonPower());
                int power = SeasonPowerRequired((level + 1) % 7);
                SetCurrentSeasonPower(power);
            } else {
                SetCurrentSeasonPower(CurrentSeasonPower() + 10);
            }
        }

        oldInput = $INPUT;
        playerSetLives(CurrentSeason());
        int level = SeasonLevel(CurrentSeasonPower());
        playerSetBombs(level);
        $SCORE = CurrentSeasonPower();
        wait(1);
    }
    return;
}

// ========================================

void SeasonReleaseEnemy() {
    flagSet(1); // no hurtbox
    flagSet(2); // no hitbox
    flagSet(128); // not killed by dialogRead or enmKillAll
    flagSet(12); // don't delete beyond screen edges (cooldown would be stuck on)

    SetReleaseInCooldown(true);

    int season = CurrentSeason();
    int seasonAlpha = SeasonAlphabeticalOrder(season);

    // (have to duplicate this logic here since enemies can't take args...)
    int level = SeasonLevel(CurrentSeasonPower());
    if (SeasonUsesOneLevel(season)) {
        level = 1;
    }

    int seasonIframes = SeasonIframes(season);
    if (IFRAMES < seasonIframes) {
        playerSetIframes(seasonIframes);
    }

    SeasonReleaseSound();

    anmSelect(4); // seasons.anm
    anmSetSprite(0, 4*seasonAlpha + 0);
    anmSetSprite(1, 4*seasonAlpha + 1);

    // Originally in TH16, the following things are all controlled by the ANM:
    //
    // - Damage source radius.  (the game reads the current value of anm_vm.scale.x)
    // - Damage source center position.  (the game computes anm_vm.final_pos())
    //     - Relevant for Doyou release, which uses its ANM script to move down.
    // - When to begin the 1.5s cooldown timer.  (the game waits until the ANM VM is deleted)
    //
    // None of these properties of the anm VM can be queried from ECL, however,
    // so we instead port large portions of the anm script to ECL.
    //
    // To control the scales, we use the ECL floatTime instruction,
    // and have it write to these variables.
    %F2 = 1f; // inner radius
    %F3 = 1f; // outer radius

    // TH16 originally set three vars on the anm VM as some form of input parameters.
    // (the subseason ShotType does this after it creates the VMs in the first method
    //  of its vtable)
    float innerRadius0 = SeasonRadius0(season, level); // field %F0 in original
    float innerRadius1 = SeasonRadius1(season, level); // field %F1 in original
    int timeParam = SeasonTimeParam(season, level); // field $I3 in original

    // The second anm VM (the outer aura) gets larger input params.
    float outerRadius0;
    float outerRadius1;
    if (season == WINTER) {
        outerRadius0 = innerRadius0 * 1.2;
        outerRadius1 = innerRadius1 * 1.2;
    } else if (season == SPRING) {
        outerRadius0 = innerRadius0 + 16f;
        outerRadius1 = innerRadius1 + 16f;
    } else {
        outerRadius0 = innerRadius0 + 8f;
        outerRadius1 = innerRadius1 + 8f;
    }

    int damage = SeasonDamage(season);

    // Most of the anm scripts have been preserved up to the first time label,
    // but Doyou's downward motion had to be moved to ECL for the sake of our hitbox.
    if (season == DOYOU) {
        // original: posTime(60, 1, 0.0f, 48.0f, 0.0f);
        movePosRelTime(60, 1, 0.0f, 48.0f);
    }

    // At this point there is a +1 time label in all original anm scripts.
    //
    // I don't believe this actually waits a frame. (more precisely, I think the
    // anm VM runs 2 frames on the first game frame).  I believe it is here in order
    // to exit the automatic initial call to the anm parser early, giving the ShotType
    // a chance to initialize the %F0, %F1, and $I3 fields.
    //
    // I checked using frame advance with Doyou and AFAICT Doyou does appear immediately
    // at full size rather than waiting one frame at scale 1f.
    //
    // Hence, we do NOT wait a frame here.

    // All scripts had a case(7) label here but I'm not sure if it was ever used?
CASE_7:

    if (season == DOYOU) {
        // in the original scripts:
        //   scale(%F0, %F0);
        //   scaleTime(50, 0, %F1, %F1);
        //
        // Basically, doyou starts big and then shrinks.
        floatTime(0, %F2, 50, 0, innerRadius0, innerRadius1);
        floatTime(1, %F3, 50, 0, outerRadius0, outerRadius1);
    } else {
        // in the original scripts:
        //     Fall:  scaleTime(10, 4, %F0, %F0);
        //   Spring:  scaleTime(10, 4, %F0, %F1);
        //   Summer:  scaleTime(10, 4, %F0, %F1);
        //   Winter:  scaleTime(10, 4, %F0, %F1);
        //
        // Basically, these seasons begin by expanding from a point.
        //
        // Notice how the latter three all use radius1 as a y radius.
        // However, all of those three seasons had radius1 == radius0 so it didn't matter
        // and there is no need for us to track separate y scales.
        //
        // The following encodes `scaleTime(10, 4, radius0, radius0);`
        floatTime(0, %F2, 10, 4, %F2, innerRadius0);
        floatTime(1, %F3, 10, 4, %F3, outerRadius0);
    }

    // time label +10 found in all original anm scripts
    ReleaseWait(10, season, damage);

    if (season == FALL) {
        // in the original scripts:
        //   scaleTime($I3, 4, %F1, %F1);
        printf("%.12f %.12f\n", _ff %F2, _ff innerRadius0);
        floatTime(0, %F2, timeParam, 4, %F2, innerRadius1);
        floatTime(1, %F3, timeParam, 4, %F3, outerRadius1);
    }

    int slot = 0;
    times(2) {
        // Doesn't this first alpha2Time just get overwritten?
        // Anyways, this exact sequence of commands appears in all anm scripts.
        anmAlpha2Time(slot, 20, 0, 64);
        anmAlphaTime(slot, 250, 0, 64);
        anmAlpha2Time(slot, 250, 0, 64);
        slot += 1;
    }

    // wait($I3) in all original anm scripts
    ReleaseWait(timeParam, season, damage);

    // All scripts had a case(1) label here but I'm not sure if it was ever used?
CASE_1:

    slot = 0;
    times(2) {
        anmAlphaTime(slot, 20, 0, 0);
        anmAlpha2Time(slot, 20, 0, 0);
        slot += 1;
    }

    // time label +20 found in all original anm scripts
    ReleaseWait(20, season, damage);

    // All seasons set a 90 frame cooldown timer once the ShotType object
    // notices that the ANM VM has died.
    //
    // I'm not actually sure if this should be wait(90) or wait(91) for
    // best accuracy, but who cares about 1 frame.
    flagSet(32);
    wait(90);

    SetReleaseInCooldown(false);
    delete();
}

void ReleaseWait(int frames, int season, int damage) {
    // This simulates wait(n) or a time label from the original anm.
    times(frames) {
        // Synchronize the anm scales with our computed scales.
        anmScale(0, %F2, %F2);
        anmScale(1, %F3, %F3);

        // TH16 does this in the second method in the ShotType vtable for fall subseason.
        // (It actually sets the vector at offset a8 on the ANM, and I'm not sure what that is
        //  since no anm commands set it... But setting abs pos seems to work!)
        if (season == FALL) {
            ABS_X = PLAYER_X;
            ABS_Y = PLAYER_Y;
        }

        // Damage enemies within the inner circle.
        int count; // output var
        enmDamageRad(count, %FINAL_X, %FINAL_Y, %F2, -1, damage);

        // TODO: These gotta spawn season items for chaining!
        //       TH16 does this by using a mode of 4 when canceling the bullets from a release
        //       (etCancel is mode 0, and etClear is mode 1).  But what can we do?
        etCancel(%F2);

        wait(1);
    }
}

// ========================================

void SeasonReleaseSound() {
    // You love it.
    playSound(74); // PLING!!!
    playSound(77); // PSSSHHHHOSHHHHHESHHHH
    return;
}

// ========================================

void DebugAnmMenuEnemy() {
    flagSet(32); // intangible
    flagSet(12); // don't delete beyond screen edges

    movePos(0f, 200f);
    playerAllowBomb(false);
    playerAllowShot(false);

    int oldInput = 0;
    int effIndex = 0;
    int anmIndex = 0;
    int enemyId = 0;
    int caseIndex = 0;

    while(true) {
        int risingEdge = $INPUT & BitNot(oldInput);
        if (risingEdge & KEY_BOMB) {
            if ($INPUT & KEY_SHOT) {
                msgSend(0f, 0f, _f(caseIndex), 2f, enemyId);
            } else {
                if (enemyId) {
                    msgSend(0f, 0f, 0f, 1f, enemyId);
                }
                SetDebuggerGlobal(1000 * anmIndex + effIndex);
                enmCreate("DebugAnmEnemy", 0f, 0f, 1, 0, 0);
                enemyId = LAST_ENM_ID;
            }
        }

        int shiftMultiplier = 1;
        if ($INPUT & KEY_SLOW) {
            shiftMultiplier = 10;
        }

        if ($INPUT & KEY_SHOT) {
            if (risingEdge & KEY_LEFT) { caseIndex -= shiftMultiplier; }
            if (risingEdge & KEY_RIGHT) { caseIndex += shiftMultiplier; }
        } else if ($INPUT & KEY_SKIP) {
            if (risingEdge & KEY_LEFT) { %ABS_X -= _f(shiftMultiplier); }
            if (risingEdge & KEY_RIGHT) { %ABS_X += _f(shiftMultiplier); }
            if (risingEdge & KEY_UP) { %ABS_Y -= _f(shiftMultiplier); }
            if (risingEdge & KEY_DOWN) { %ABS_Y += _f(shiftMultiplier); }
            msgSend(%ABS_X, %ABS_Y, 0f, 0f, enemyId);
        } else {
            if (risingEdge & KEY_LEFT) { effIndex -= shiftMultiplier; }
            if (risingEdge & KEY_RIGHT) { effIndex += shiftMultiplier; }
            if (risingEdge & KEY_DOWN) { anmIndex -= 1; }
            if (risingEdge & KEY_UP) { anmIndex += 1; }
        }

        playerPos(0f, 400f);
        drawColor(0xFFFF0000);
        drawf(0f, 0f, "INPUT %x", _SS $INPUT);
        drawf(0f, 12f, "ANM %d (UD) SCR %d (LR)", _SS anmIndex, _SS effIndex);
        if ($INPUT & KEY_SHOT) {
            drawf(0f, 24f, "Z+X to do anmSwitch(%d)", _SS caseIndex);
        }
        oldInput = $INPUT;
        wait(1);
    }
    return;
}

void DebugAnmEnemy() {
    msgReset(ID);

    flagSet(1); // no hurtbox
    flagSet(2); // no hitbox
    flagSet(12); // don't delete beyond screen edges

    int value = DebuggerGlobal();
    playSound(1);
    anmSelect(value / 1000);
    anmSetSprite(0, value % 1000);

    while (true) {
        int received;
        msgCheck(received, ID);
        while (received) {
            float a, b, c, d;
            msgReceive(received, a, b, c, d, ID);
            if (d == 0f) { movePos(a, b); }
            if (d == 1f) { delete(); }
            if (d == 2f) { anmSwitch(0, _S(c)); }
        }
        wait(1);
    }
}


void SoundTestEnemy() {
    flagSet(32); // intangible
    flagSet(12); // don't delete beyond screen edges

    playerAllowBomb(false);
    playerAllowShot(false);

    int oldInput = 0;
    int soundIndex = 0;

    while(true) {
        int risingEdge = $INPUT & BitNot(oldInput);
        if (risingEdge & KEY_SHOT) {
            playSound(soundIndex);
        }

        int shiftMultiplier = 1;
        if ($INPUT & KEY_SLOW) {
            shiftMultiplier = 10;
        }

        if (risingEdge & KEY_LEFT) { soundIndex -= shiftMultiplier; }
        if (risingEdge & KEY_RIGHT) { soundIndex += shiftMultiplier; }

        playerPos(0f, 400f);
        drawColor(0xFFFF0000);
        drawf(0f, 12f, "SOUND %d", _SS soundIndex);
        drawColor(0xFFFFFFFF);
        oldInput = $INPUT;
        wait(1);
    }
    return;
}

