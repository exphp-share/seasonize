# Binhacks that provide other binhacks in the patch with an interface
# for working with global variables and additional data.

binhacks:
  # Every time an enemy is allocated, also allocate an instance
  # of our EnemyEx datatype.
  Allocate season data for enemies:
    addr: "0x41ed32"
    expected: "8b8190000000"
    codecave:
      - "51                " # push   ecx
      - "52                " # push   edx

      # at this point, eax holds enemy id
      - "50                " # push eax
      - "E8 [codecave:ExpHP.seasons-everywhere.new-enemy-ex]" # call

      - "5A                " # pop    edx
      - "59                " # pop    ecx

      # original code
      - "8B8190000000      " # mov    eax, dword [ecx+0x90]
      # abs_jmp_hack 0x41ed38
      - "E800000000        " # <1>  call %%next
      - "C7042438ED4100    " # <1>  mov dword [esp], %1
      - "C3                " # <1>  ret

  # Free those EnemyExes with the enemies.
  Free season data for enemies:
    addr: "0x41db7a"
    expected: "8b8690520000"
    codecave:
      - "51                " # push   ecx
      - "52                " # push   edx

      - "FFB660570000      " # push   dword [esi+efull_id]
      - "E8 [codecave:ExpHP.seasons-everywhere.free-enemy-ex-by-id]" # call

      - "5A                " # pop    edx
      - "59                " # pop    ecx

      # original code
      - "8B8690520000      " # mov    eax, dword [esi+0x5290]
      - "E800000000        " # <1>  call %%next
      - "C7042480DB4100    " # <1>  mov dword [esp], %1
      - "C3                " # <1>  ret

codecaves:
  # So that we can use a codecave to store data.
  protection: 0x40 # PAGE_EXECUTE_READWRITE

  #==============================================
  # Global variables
  ExpHP.seasons-everywhere.global-var-store:
    - "00000000" # offset 0x0000:  ZunList enemy_ex_head;
    - "00000000"
    - "00000000"
    - "00000000"
    - "" #                0x0010:  TOTAL SIZE

  #==============================================
  # Types

  # struct EnemyEx {
  #   ZunList node;
  #   int enemy_id;
  #   int damage_per_season_item;
  #   int damage_accounted_for_season_items;
  #   ZunTime bonus_timer;
  #   int item_max;
  #   int item_min;
  # }

  # stdcall EnemyEx* NewEnemyEx(id)
  ExpHP.seasons-everywhere.new-enemy-ex:
    - "55                " # push   ebp
    - "89E5              " # mov    ebp, esp
    - "56                " # push   esi
    - "57                " # push   edi

    - "6A3C              " # push   EnemyEx_size
    - "E8 [codecave:ExpHP.seasons-everywhere.calloc]" # call
    - "89C7              " # mov    edi, eax

    - "BE <codecave:ExpHP.seasons-everywhere.global-var-store>" # mov esi, GLOBALS

    - "8D0E              " # lea    ecx, [esi+g_enemy_ex_head]
    - "51                " # push   ecx
    - "89F9              " # mov    ecx, edi
    - "E8 [codecave:ExpHP.seasons-everywhere.zunlist-insert-after]" # call

    - "8B4508            " # mov    eax, [ebp+0x8]
    - "894710            " # mov    [edi+ex_id], eax

    # Default is as if we called spec0(60, 10, 1).
    - "C747340A000000    " # mov    dword [edi+ex_item_max], 0xa
    - "C7473801000000    " # mov    dword [edi+ex_item_min], 0x1
    - "C747303C000000    " # mov    dword [edi+ex_max_time], 0x3c
    - "8D4F1C            " # lea    ecx, [edi+ex_bonus_timer]
    - "6A3C              " # push   0x3c ; 60
    - "B8C05B4000        " # mov    eax, TIMER_SET_VALUE
    - "FFD0              " # call   eax

    # return the EnemyEx
    - "89F8              " # mov    eax, edi
    - "5F                " # pop    edi
    - "5E                " # pop    esi

    - "89EC              " # mov    esp, ebp
    - "5D                " # pop    ebp
    - "C20400            " # ret    0x4

  # stdcall void FreeEnemyExById(id)
  ExpHP.seasons-everywhere.free-enemy-ex-by-id:
    - "55                " # push   ebp
    - "89E5              " # mov    ebp, esp

    - "8B4508            " # mov    eax, [ebp+0x8]
    - "50                " # push   eax
    - "E8 [codecave:ExpHP.seasons-everywhere.find-enemy-ex-by-id]" # call
    - "89C1              " # mov    ecx, eax
    - "E8 [codecave:ExpHP.seasons-everywhere.zunlist-remove-node]" # call

    - "6A3C              " # push   EnemyEx_size
    - "50                " # push   eax
    - "B880B24700        " # mov    eax, FREE_SIZED
    - "FFD0              " # call   eax

    - "89EC              " # mov    esp, ebp
    - "5D                " # pop    ebp
    - "C20400            " # ret    4

  # [esp+0x4] is an enemy id.
  ExpHP.seasons-everywhere.find-enemy-ex-by-id:
    - "B9 <codecave:ExpHP.seasons-everywhere.global-var-store>" # mov    ecx, GLOBALS
    - "8D09                      " # lea    ecx, [ecx+g_enemy_ex_head]
    - "8B542404                  " # mov    edx, [esp+0x4]  ; desired id
    - "8B4104                    " # mov    eax, [ecx+l_next]
    # .loop:
    - "85C0                      " # test   eax, eax
    - "740D                      " # jz     .notfound
    - "3B5010                    " # cmp    edx, [eax+ex_id]
    - "7405                      " # je     .found
    - "8B4004                    " # mov    eax, [eax+l_next]
    - "EBF2                      " # jmp    .loop
    # .found:
    - "C20400                    " # ret 4
    # .notfound:
    - "0F0B                      " # ud2

  # extern __stdcall int GetSeason(void);
  ExpHP.seasons-everywhere.get-season:
    # Query ECLPlus
    - "6A 00                 " # push   0          ; arg 3: mode    (0 = get value)
    - "68 CAE0FFFF           " # push   VAR_FLAGS  ; arg 2: var ID
    - "6A 00                 " # push   0          ; arg 1: enemy   (null)
    - "E8 [codecave:ExpHP.seasons-everywhere.eclplus-int-switch]" # call
    - "83E0 07               " # and    eax, 0x7
    - "C3                    " # ret

  # extern __stdcall int GetTokenSetting(void);
  ExpHP.seasons-everywhere.get-token-setting:
    # Query ECLPlus
    - "6A 00                 " # push   0          ; arg 3: mode    (0 = get value)
    - "68 CAE0FFFF           " # push   VAR_FLAGS  ; arg 2: var ID
    - "6A 00                 " # push   0          ; arg 1: enemy   (null)
    - "E8 [codecave:ExpHP.seasons-everywhere.eclplus-int-switch]" # call
    - "C1E8 03               " # shr    eax, 3
    - "83E0 07               " # and    eax, 0x7
    - "C3                    " # ret

  # returns enemy id if there is a release, -1 if in cooldown, 0 otherwise.
  # extern __stdcall int GetActiveRelease(void);
  ExpHP.seasons-everywhere.get-active-release:
    - "6A 00                 " # push    0                   ; arg 3: mode    (0 = get value)
    - "68 CCE0FFFF           " # push    VAR_ACTIVE_RELEASE  ; arg 2: var ID
    - "6A 00                 " # push    0                   ; arg 1: enemy   (null)
    - "E8 [codecave:ExpHP.seasons-everywhere.eclplus-int-switch]" # call
    - "C3                    " # ret

  # Wrapper around ECLPlus' IntVarSwitch that preserves the volatile ecx, edx, and xmm registers.
  #
  # (this is done because, even though xmm registers are technically volatile,
  #  it is far easier to reason about them in assembly as if they are mostly
  #  almost nonvolatile, because rampart compiler optimizations have allowed
  #  the compiler to avoid saving and restoring them across function calls
  #  when it knows that the callee doesn't clobber these registers)
  ExpHP.seasons-everywhere.eclplus-int-switch:
    # Prologue that saves volatile registers
    - "55                    " # push   ebp
    - "89 E5                 " # mov    ebp,esp
    - "83 e4f0               " # and    esp,0xfffffff0   # align for movaps
    - "81 ec80000000         " # sub    esp,0x80
    - "0f290424              " # movaps XMMWORD PTR [esp],xmm0
    - "0f294c2410            " # movaps XMMWORD PTR [esp+0x10],xmm1
    - "0f29542420            " # movaps XMMWORD PTR [esp+0x20],xmm2
    - "0f295c2430            " # movaps XMMWORD PTR [esp+0x30],xmm3
    - "0f29642440            " # movaps XMMWORD PTR [esp+0x40],xmm4
    - "0f296c2450            " # movaps XMMWORD PTR [esp+0x50],xmm5
    - "0f29742460            " # movaps XMMWORD PTR [esp+0x60],xmm6
    - "0f297c2470            " # movaps XMMWORD PTR [esp+0x70],xmm7
    - "51                    " # push   ecx
    - "52                    " # push   edx

    # Forward args to ECLPlus
    - "ff 75 10              " # push   DWORD PTR [ebp+0x10]
    - "ff 75 0c              " # push   DWORD PTR [ebp+0xc]
    - "ff 75 08              " # push   DWORD PTR [ebp+0x8]
    - "FF15 E49F4900         " # call dword [0x499FE4]   # pointer to ECLplus.dll+IntVarSwitch

    # Epilogue that restores volatile registers
    - "5a                    " # pop    edx
    - "59                    " # pop    ecx
    - "0f280424              " # movaps xmm0,XMMWORD PTR [esp]
    - "0f284c2410            " # movaps xmm1,XMMWORD PTR [esp+0x10]
    - "0f28542420            " # movaps xmm2,XMMWORD PTR [esp+0x20]
    - "0f285c2430            " # movaps xmm3,XMMWORD PTR [esp+0x30]
    - "0f28642440            " # movaps xmm4,XMMWORD PTR [esp+0x40]
    - "0f286c2450            " # movaps xmm5,XMMWORD PTR [esp+0x50]
    - "0f28742460            " # movaps xmm6,XMMWORD PTR [esp+0x60]
    - "0f287c2470            " # movaps xmm7,XMMWORD PTR [esp+0x70]
    - "89 EC                 " # mov    esp,ebp
    - "5D                    " # pop    ebp

    - "C2 0c00               " # ret    0xc
