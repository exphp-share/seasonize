



binhacks:
  Season items go in PIV item array: 
    addr: "0x0043476d"
    expected: 
      # A bunch of equality checks
      - "83FF 09 0F84 95020000"
      - "83FF 0A 0F84 8C020000"
      - "83FF 0B 0F84 83020000"
      - "83FF 0C 0F84 7A020000"
    code:
      - "83FF 09          " # cmp edi,0x9
      # "0F8C [Rx004347a3]" # jl  USE_STANDARD_ARRAY
      - "7C 31 // 90909090" 

      - "83FF 0f          " # cmp edi,0xf
      # "0F8E [Rx00434a0b]" # jle USE_PIV_ITEM_ARRAY
      - "0F8E 8C020000    "

      - "83FF 30          " # cmp edi,0x30
      # "0F84 [Rx00434a0b]" # je 0x00434a0b (USE_PIV_ITEM_ARRAY)
      - "0F84 83020000    "

      # "E9 [Rx004347a3]  " # jl  USE_STANDARD_ARRAY
      - "EB 19 // CCCCCC  "
      - "CCCCCCCC         " # int 3

  Set season item ANM script:
    addr: "0x004334b3"
    expected: "C787 580C0000 02000000 // FF 34 C5 A80D4A00"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.item-anm-script]"  # jmp
      - "0F1F440000       " # NOP DWORD ptr [EAX + EAX*1 + 00]
      - "0F1F8000000000   " # NOP DWORD ptr [EAX + 00000000H]

  Season items on graze:
    addr: "0x0044a0dc"
    expected: "5f // 5e // 8be5 // 5d"
    code: "E9 [codecave:ExpHP.seasons-everywhere.item-on-graze]"

  Season item flyout state implementation:
    addr: "0x0043386d"
    expected: "83F8 03 // 74 B1"
    code: "E9 [codecave:ExpHP.seasons-everywhere.item-flyout-state]"

  Season item in flyout state cannot be attracted:
    addr: "0x433fd7"
    expected:
      - "83f804 // 0f84b8000000"
      - "83f803 // 0f84af000000"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.item-noattract]"
      - "CCCCCCCC"
      - "CCCCCC // CCCCCCCCCCCC"

  Season item pickup effect:
    addr: "0x433b2d"
    expected: "8d41ff // 83f80d"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.item-pickup-effect]"
      - "CC"

  Season release autocollects items in Falling state:
    addr: "0x433590"
    expected: "a1 88764b00"
    code: "E9 [codecave:ExpHP.seasons-everywhere.autocollect-state-1]"

  Season release autocollects items in Attracted state:
    addr: "0x4338b3"
    expected: "a1 88764b00"
    code: "E9 [codecave:ExpHP.seasons-everywhere.autocollect-state-4]"

  Use season release bullet cancel mode:
    addr: "0x425c9f"
    expected: "6a01 // 8bcf // f30f1185 98fbffff"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.use-release-cancel-mode]"
      - "CCCCCC CCCCCCCC"

  Implement season bullet cancel modes:
    addr: "0x419c9c"
    expected: "83fa01 // 7544"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.impl-cancel-modes]"

  Allocate season data for enemies:
    addr: "0x41ed32"
    expected: "8b8190000000"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.allocate-enemy-exes]"
      - "CC"

  Free season data for enemies:
    addr: "0x41db7a"
    expected: "8b8690520000"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.deallocate-enemy-exes]"
      - "CC"

  Enemies can drop season items:
    addr: "0x41da35"
    expected: "6888000000"
    code:
      - "E9 [codecave:ExpHP.seasons-everywhere.drop-season-items]"

codecaves:
  # So that we can use a codecave to store data.
  protection: 0x40 # PAGE_EXECUTE_READWRITE

  #==============================================
  # Global variables
  ExpHP.seasons-everywhere.global-var-store:
    - "00000000" # offset 0x0000:  ZunList enemy_ex_head;
    - "00000000"
    - "00000000"
    - "00000000"
    - "" #                0x0010:  TOTAL SIZE

  #==============================================
  # Types

  # struct EnemyEx {
  #   ZunList node;
  #   int enemy_id;
  #   int damage_per_season_item;
  #   int damage_accounted_for_season_items;
  #   ZunTime bonus_timer;
  #   int item_max;
  #   int item_min;
  # }

  # stdcall EnemyEx* NewEnemyEx(id)
  ExpHP.seasons-everywhere.new-enemy-ex:
    - "55                " # push   ebp
    - "89E5              " # mov    ebp, esp
    - "56                " # push   esi
    - "57                " # push   edi

    - "6A3C              " # push   EnemyEx_size
    - "E8 [codecave:ExpHP.seasons-everywhere.calloc]" # call
    - "89C7              " # mov    edi, eax

    - "BE <codecave:ExpHP.seasons-everywhere.global-var-store>" # mov esi, GLOBALS

    - "8D0E              " # lea    ecx, [esi+g_enemy_ex_head]
    - "51                " # push   ecx
    - "89F9              " # mov    ecx, edi
    - "E8 [codecave:ExpHP.seasons-everywhere.zunlist-insert-after]" # call

    - "8B4508            " # mov    eax, [ebp+0x8]
    - "894710            " # mov    [edi+ex_id], eax

    - "C747340A000000    " # mov    dword [edi+ex_item_max], 0xa
    - "C7473801000000    " # mov    dword [edi+ex_item_min], 0x1
    - "C747303C000000    " # mov    dword [edi+ex_max_time], 0x3c
    - "8D4F1C            " # lea    ecx, [edi+ex_bonus_timer]
    - "6A3C              " # push   0x3c ; 60
    - "B8C05B4000        " # mov    eax, TIMER_SET_VALUE
    - "FFD0              " # call   eax

    # return the EnemyEx
    - "89F8              " # mov    eax, edi
    - "5F                " # pop    edi
    - "5E                " # pop    esi

    - "89EC              " # mov    esp, ebp
    - "5D                " # pop    ebp
    - "C20400            " # ret    0x4

  # stdcall void FreeEnemyExById(id)
  ExpHP.seasons-everywhere.free-enemy-ex-by-id:
    - "55                " # push   ebp
    - "89E5              " # mov    ebp, esp

    - "8B4508            " # mov    eax, [ebp+0x8]
    - "50                " # push   eax
    - "E8 [codecave:ExpHP.seasons-everywhere.find-enemy-ex-by-id]" # call
    - "89C1              " # mov    ecx, eax
    - "E8 [codecave:ExpHP.seasons-everywhere.zunlist-remove-node]" # call

    - "6A3C              " # push   EnemyEx_size
    - "50                " # push   eax
    - "B880B24700        " # mov    eax, FREE_SIZED
    - "FFD0              " # call   eax

    - "89EC              " # mov    esp, ebp
    - "5D                " # pop    ebp
    - "C20400            " # ret    4

  # [esp+0x4] is an enemy id.
  ExpHP.seasons-everywhere.find-enemy-ex-by-id:
    - "B9 <codecave:ExpHP.seasons-everywhere.global-var-store>" # mov    ecx, GLOBALS
    - "8D09                      " # lea    ecx, [ecx+g_enemy_ex_head]
    - "8B542404                  " # mov    edx, [esp+0x4]  ; desired id
    - "8B4104                    " # mov    eax, [ecx+l_next]
    # .loop:
    - "85C0                      " # test   eax, eax
    - "740D                      " # jz     .notfound
    - "3B5010                    " # cmp    edx, [eax+ex_id]
    - "7405                      " # je     .found
    - "8B4004                    " # mov    eax, [eax+l_next]
    - "EBF2                      " # jmp    .loop
    # .found:
    - "C20400                    " # ret 4
    # .notfound:
    - "0F0B                      " # ud2

  #==============================================
  # Code

  ExpHP.seasons-everywhere.allocate-enemy-exes:
    - "51                " # push   ecx
    - "52                " # push   edx

    # at this point, eax holds enemy id
    - "50                      " # push eax
    - "E8 [codecave:ExpHP.seasons-everywhere.new-enemy-ex]" # call

    - "5A                " # pop    edx
    - "59                " # pop    ecx

    # original code
    - "8B8190000000      " # mov    eax, dword [ecx+0x90]
    # abs_jmp_hack 0x41ed38
    - "E800000000        " # <1>  call %%next
    - "C7042438ED4100    " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

  ExpHP.seasons-everywhere.deallocate-enemy-exes:
    - "51                " # push   ecx
    - "52                " # push   edx

    - "FFB660570000      " # push   dword [esi+efull_id]
    - "E8 [codecave:ExpHP.seasons-everywhere.free-enemy-ex-by-id]" # call

    - "5A                " # pop    edx
    - "59                " # pop    ecx

    # original code
    - "8B8690520000      " # mov    eax, dword [esi+0x5290]
    - "E800000000        " # <1>  call %%next
    - "C7042480DB4100    " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

  ExpHP.seasons-everywhere.item-anm-script:
    - "83F8 30               " # cmp eax, 0x30
    - "74 13                 " # je season
    # non-season:
    - "C787 580C0000 02000000" # mov dword [edi + 0xc58], 2   ; Item::state  (2 = rising PIV item)
    - "FF34C5 A80D4A00       " # push dword [eax*8 + 0x4a0da8]
    - "EB 15                 " # jmp finish
    # season:
    # FIXME: This needs its own state (season item flyout state;  state 3 from TH16)
    - "C787 580C0000 09000000  " # mov dword [edi + 0xc58], 9   ; Item::state  (9 = season flyout)
    - "E8 [codecave:ExpHP.seasons-everywhere.get-season]" # call GetSeason()
    - "05 81000000             " # add eax, 0x81
    - "50                      " # push eax
    # finish:
    # "E8 [Rx004334b8]             "
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E8 00000000                 " # call next ins
    - "C70424 B8344300             " # mov [esp], 004334b8
    - "C3                          " # ret

  ExpHP.seasons-everywhere.item-on-graze:
    - "8B15 D0774B00               " # mov edx, [0x4b77d0]  ; PLAYER
    - "8D92 10060000               " # lea edx, [edx+0x610] ; player pos
    - "8B7B 08                     " # mov edi, [ebx+0x8] ; bullet pos
    - "83EC 20                     " # sub esp, 0x20 ; spawn_item has 8 args

    # Compute angle away from player.
    - "F30F1047 04                 " # movss xmm0, [edi + 4]  ; bullet y
    - "F30F5C42 04                 " # subss xmm0, [edx + 4]  ; bullet y - player y
    - "F30F114424 0C               " # movss DWORD [esp + 0xc], xmm0  ; use vel_angle arg as scratch
    - "D94424 0C                   " # fld DWORD [esp + 0xc]
    - "F30F1007                    " # movss xmm0, [edi]  ; bullet x
    - "F30F5C02                    " # subss xmm0, [edx]  ; bullet x - player x
    - "F30F114424 0C               " # movss DWORD [esp + 0xc], xmm0
    - "D94424 0C                   " # fld DWORD [esp + 0xc]
    # "E8 [Rx00496E70]             " # call math_atan2  ; math_atan2
    - "B8 706E4900                 " # mov eax, math_atan2
    - "FF D0                       " # call eax

    # Args 3 and 7 are totally unused, and arg 6 is unused for season items.
    - "C74424 1C FFFFFFFF          " # mov  DWORD [esp + 0x1c], 0xffffffff ; arg 8: unknown (TODO)
    - "C74424 10 3333F33F          " # mov  DWORD [esp + 0x10], 0x3ff33333 ; arg 5: vel_norm  (1.9f)
    - "D95C24 0C                   " # fstp DWORD [esp + 0xc]              ; arg 4: vel_angle
    - "897C24 04                   " # mov  DWORD [esp + 0x4], edi         ; arg 2: pos
    - "C70424 30000000             " # mov  DWORD [esp + 0x0], 0x30        ; arg 1: item type

    - "8B0D B8764B00               " # mov ecx, [0x4b76b8]  ; ITEM_MANAGER
    # "E8 [Rx00434740]             " # call spawn_item
    - "B8 40474300                 " # mov eax, spawn_item
    - "FF D0                       " # call eax

    - "5f // 5e // 8be5 // 5d      " # original code (pop edi, pop esi, etc.)
    # "E8 [Rx0044a0e1]             "
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E8 00000000                 " # call next ins
    - "C70424 E1A04400             " # mov [esp], 0x0044a0e1
    - "C3                          " # ret

  ExpHP.seasons-everywhere.item-pickup-effect:
    - "83F930                    " #  cmp     ecx, 0x30
    - "7413                      " #  je      .effect
   
    # original code
    - "8D41FF                    " #  lea     eax, [ecx-0x1]
    - "83F80D                    " #  cmp     eax, 0xd
   
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E800000000                " #  call    (next instruction)
    - "C70424333B4300            " #  mov     dword [esp], 0x00433b33
    - "C3                        " #  ret
   
    # .effect:
    - "E8 [codecave:ExpHP.seasons-everywhere.increment-season-power]" #  call
    - "85C0                      " #  test    eax, eax
    - "7422                      " #  jz      .skip
   
    # .season_level_increase:
    # At this point, TH16 calls a method on Player to make it regenerate its options.
    # We haven't implemented subseason options (...yet?), so there's no point.
   
    # Make "PowerUp" floaty text
    - "6840FFFFFF                " #  push    0xffffff40  ; color
    - "6AFF                      " #  push    0xffffffff  ; value -1 (displays "PowerUp")
    - "8DB7100C0000              " #  lea     esi, [edi+0xc10]  ; Item::position
    - "56                        " #  push    esi
    - "B8 700b4500               " #  mov     eax, 0x450b70  ; generate_chinese_numeral_popup
    - "FFD0                      " #  call    eax

    # Play sound effect for level up
    - "F30F1016                  " #  movss   xmm2, dword [esi]
    - "6A3F                      " #  push    0x3f
    - "B8 F0544600                " #  mov     eax, 0x4654f0  ; play_sound_at_position
    - "FFD0                      " #  call    eax
   
    # TH16 adds 10 points to score here.
    # We don't bother because it's unclear how well this would balance
    # with TH17 scoring, and also because add_to_score is small enough
    # in TH17 that it got inlined everywhere. (yet is still nontrivial)
   
    # .skip:
    # other item pickup branches in TH17 do this if they modified esi
    - "8B35D0774B00              " #  mov     esi, dword [0x4b77d0]
    - "8974240C                  " #  mov     dword [esp+0xc], esi
   
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E800000000                " #  call    (next instruction)
    - "C70424863F4300            " #  mov     dword [esp], 0x433f86
    - "C3                        " #  ret

  # extern "stdcall" int GetSeason(void);
  # Additionally preserves ecx, edx, and xmm registers, but not the FPU.
  ExpHP.seasons-everywhere.get-season:
    # Query ECLPlus
    - "6A 00                 " # push    0           ; arg 3: mode    (0 = get value)
    - "68 CAE0FFFF           " # push    VAR_SEASON  ; arg 2: var ID
    - "6A 00                 " # push    0           ; arg 1: enemy   (null)
    - "E8 [codecave:ExpHP.seasons-everywhere.eclplus-int-switch]" # call
    - "C3                    " # ret

  # returns enemy id if there is a release, -1 if in cooldown, 0 otherwise.
  ExpHP.seasons-everywhere.get-active-release:
    - "6A 00                 " # push    0                   ; arg 3: mode    (0 = get value)
    - "68 CCE0FFFF           " # push    VAR_ACTIVE_RELEASE  ; arg 2: var ID
    - "6A 00                 " # push    0                   ; arg 1: enemy   (null)
    - "E8 [codecave:ExpHP.seasons-everywhere.eclplus-int-switch]" # call
    - "C3                    " # ret

  # Several places in the item update code check the following two conditions for autocollection:
  # - Is there an active bomb less than 60 frames old?
  # - Is there an active release, period?
  #
  # (of course, TH17 only checks the first condition. We add the latter!)
  ExpHP.seasons-everywhere.is-bomb-or-release-autocollecting:
    - "A188764B00        " # mov     eax, [SHOTTYPE_PTR]
    - "83783001          " # cmp     dword [eax+st_bomb_is_active], 0x1
    - "7508              " # jne     .nobomb
    - "8378383C          " # cmp     dword [eax+st_bomb_time], 0x3c  ; < 60 frames
    - "7D02              " # jge     .nobomb
    - "EB0E              " # jmp     .success
    # .nobomb:
    - "E8 [codecave:ExpHP.seasons-everywhere.get-active-release]" # call    codecave_get_active_release
    - "85C0              " # test    eax, eax
    - "7E02              " # jng     .norelease    ; positive (active)
    - "EB03              " # jmp     .success
    # .norelease:
    - "31C0              " # xor     eax, eax
    - "C3                " # ret
    # .success:
    - "B801000000        " # mov     eax, 0x1
    - "C3                " # ret

  # extern "stdcall" int IncrementSeasonPower();
  #
  # Simulates th16.exe+3de50  `int item_collect_season(DWORD __unused)`.
  # (we don't bother taking an argument like the original did).
  # Increases season power by 1 (up to cap).
  # Return value is 1 if season level has just increased.
  #
  # Additionally preserves xmm registers, ecx, and edx, but not the FPU.
  ExpHP.seasons-everywhere.increment-season-power:
    - "51                    " # push ecx
    - "52                    " # push edx
   
    # Query ECLPlus
    - "6A 01                 " # push 1      # arg 3: mode    (1 = get pointer)
    - "68 CBE0FFFF           " # push -7989  # arg 2: var ID  (GI5)
    - "6A 00                 " # push 0      # arg 1: enemy   (null)
    - "E8 [codecave:ExpHP.seasons-everywhere.eclplus-int-switch]" # call
   
    # Stop now if already max season
    - "8138 74040000         " # cmp    DWORD [eax], 1140
    - "7D 33                 " # jnl    .bad
   
    # increment and find out if we hit a requirement
    - "FF00                  " # inc    DWORD [eax]
   
    - "8B00                  " # mov    eax, [eax]
    - "83F8 64               " # cmp    eax, 100
    - "74 27                 " # je     .good
    - "3D E6000000           " # cmp    eax, 230
    - "74 20                 " # je     .good
    - "3D 86010000           " # cmp    eax, 390
    - "74 19                 " # je     .good
    - "3D 4E020000           " # cmp    eax, 590
    - "74 12                 " # je     .good
    - "3D 48030000           " # cmp    eax, 840
    - "74 0B                 " # je     .good
    - "3D 74040000           " # cmp    eax, 1140
    - "74 04                 " # je     .good
   
    # .bad:
    - "31C0                  " # xor    eax, eax
    - "EB 05                 " # jmp    .end
    # .good:
    - "B8 01000000           " # mov    eax, 1
    # .end:
    - "5A                    " # pop edx
    - "59                    " # pop ecx
    - "C3                    " # ret

  # Implements item state 9 (equivalent to TH16's item state 3)
  ExpHP.seasons-everywhere.item-flyout-state:
    # Fit in an extra branch for state 9 after the branch for state 3
    - "83F8 03                   " # cmp eax, 0x3
    - "74 07                     " # je .jmp_to_case_3
    - "83F8 09                   " # cmp eax, 0x9
    - "74 1C                     " # je .case_9
    - "EB 0D                     " # jmp .jmp_to_more_cases
   
    # .jmp_to_case_3:
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E8 00000000               " # call (next instruction)
    - "C70424 23384300           " # mov     dword [esp], 0x433823  ; state 3 code
    - "C3                        " # ret
   
    # .jmp_to_more_cases:
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E8 00000000               " # call (next instruction)
    - "C70424 72384300           " # mov     dword [esp], 0x433872  ; next in if-then-else chain
    - "C3                        " # ret
   
    # .case_9:
    # Move in a straight line
    - "F30F1005 18594B00         " # movss   xmm0, dword [0x004b5918]  ; GAME_SPEED
    - "F30F108F 1C0C0000         " # movss   xmm1, dword [edi+0xc1c] ; {Item::velocity.x}
    - "F30F1097 200C0000         " # movss   xmm2, dword [edi+0xc20] ; {Item::velocity.y}
    - "F30F109F 240C0000         " # movss   xmm3, dword [edi+0xc24] ; {Item::velocity.z}
    - "F30F59C8                  " # mulss   xmm1, xmm0
    - "F30F59D0                  " # mulss   xmm2, xmm0
    - "F30F59D8                  " # mulss   xmm3, xmm0
    - "F30F588F 100C0000         " # addss   xmm1, dword [edi+0xc10] ; {Item::position.x}
    - "F30F5897 140C0000         " # addss   xmm2, dword [edi+0xc14] ; {Item::position.y}
    - "F30F589F 180C0000         " # addss   xmm3, dword [edi+0xc18] ; {Item::position.z}
    - "F30F118F 100C0000         " # movss   dword [edi+0xc10], xmm1 ; {Item::position.x}
    - "F30F1197 140C0000         " # movss   dword [edi+0xc14], xmm2 ; {Item::position.y}
    - "F30F119F 180C0000         " # movss   dword [edi+0xc18], xmm3 ; {Item::position.z}
   
    # Reduce velocity magnitude by 0.03f, compute new velocity vector.
    # TH16 doesn't multiply this by GAME_SPEED, so we won't either.
    # (seems like a bug to me though...)
    - "F30F1087 280C0000         " # movss   xmm0, dword [edi+0xc28]  ; {Item::velocity_magnitude}
    - "F30F5C05 C03A4A00         " # subss   xmm0, dword [0x004a3ac0]  ; 0.03f
    - "F30F1187 280C0000         " # movss   dword [edi+0xc28], xmm0  ; {Item::velocity_magnitude}
    - "83EC 08                   " # sub     esp, 0x8
    - "F30F114424 04             " # movss   dword [esp+0x4], xmm0  ; arg 2: magnitude
    - "F30F1087 2C0C0000         " # movss   xmm0, dword [edi+0xc2c]  ; {Item::velocity_angle}
    - "F30F110424                " # movss   dword [esp], xmm0  ; arg 1: angle
    - "8D8F 1C0C0000             " # lea     ecx, [edi+0xc1c]  ; arg 0: output
    - "B8 F04C4300               " # mov     eax, 0x434cf0  ; cartesian_from_polar
    - "FFD0                      " # call    eax
   
    # TODO: TEST SEASON AUTOCOLLECT (graze and then quickly use spring release)
    #
    # If a bomb/release autocollects during any frame of the flyout state,
    # the item will be autocollected once it stops moving
    - "E8 [codecave:ExpHP.seasons-everywhere.is-bomb-or-release-autocollecting]" # call
    - "0987700C0000              " # or      [edi+en_force_autocollect], eax

    # Has this item stopped moving?
    - "0F2FAF 280C0000           " # comiss  xmm5, dword [edi+0xc28] ; compare 0.0f to {Item::velocity_magnitude}
    - "7315                      " # jnb     .velocity_nonpositive
   
    # LABEL .velocity_positive:
    # Jump to code that deletes out of bounds and collects touched items.

    - "F30F1087 140C0000         " # movss   xmm0, dword [edi+0xc14] ; {Item::position.y}
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E8 00000000               " #  call    (next instruction)
    - "C70424 27374300           " #  mov     dword [esp], 0x00433727
    - "C3                        " #  ret
   
    # LABEL .velocity_nonpositive:
    # If force_autocollect, next state is autocollected.
    #            otherwise, next state is falling.
    - "8B35 D0774B00             " #  mov     esi, dword [0x4b77d0]  ; PLAYER_STRUCT_PTR
   
    - "83BF 700C0000 00          " #  cmp     dword [edi+0xc70], 0x0  ; {Item::force_autocollect__season_only}
    - "B8 03000000               " #  mov     eax, 0x3  ; autocollected state
    - "B9 01000000               " #  mov     ecx, 0x1  ; falling state
    - "0F44C1                    " #  cmove   eax, ecx
    - "8987 580C0000             " #  mov     dword [edi+0xc58], eax  ; {Item::state}
   
    # These velocity fields will be used if we switch to falling.
    - "C787 1C0C0000 00000000    " #  mov     dword [edi+0xc1c], 0x0  ; {Item::velocity.x}
    - "C787 200C0000 00000000    " #  mov     dword [edi+0xc20], 0x0  ; {Item::velocity.y}
    - "C787 240C0000 00000000    " #  mov     dword [edi+0xc24], 0x0  ; {Item::velocity.z}
    - "C787 280C0000 00000000    " #  mov     dword [edi+0xc28], 0x0  ; {Item::velocity_magnitude}
    - "C787 2C0C0000 DB0FC93F    " #  mov     dword [edi+0xc2c], 0x3fc90fdb  ; {Item::velocity_angle} {PI/2; straight down}
   
    # These velocity fields will be used if we switch to autocollected.
    # To find these offsets just find the place where the rising state transitions to
    # the autocollected state (0x0043380a in TH17)
    - "8B86 3C900100             " #  mov     eax, dword [esi+0x1903c]  ; {Player::__unknown_field}
    - "8B40 08                   " #  mov     eax, dword [eax+0x8]
    - "8987 640C0000             " #  mov     dword [edi+0xc64], eax  ; {Item::velocity_magnitude_towards_player}
    - "8B4C24 10                 " #  mov     ecx, dword [esp+0x10]  ; restore ItemManager to ecx
   
    # Jump to body of Falling state, regardless of which state we have become.
    # It's only for one frame and velocity is zero, so we won't actually fall if autocollected.
    #
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    - "E8 00000000               " #  call    (next instruction)
    - "C70424 20354300           " #  mov     dword [esp], 0x00433520
    - "C3                        " #  ret

  ExpHP.seasons-everywhere.autocollect-state-1:
    - "E8 [codecave:ExpHP.seasons-everywhere.is-bomb-or-release-autocollecting]" # call
    - "85C0              " # test    eax, eax
    - "740D              " # jz      .failure
    # .success:
    # abs_jmp_hack 0x43380a
    - "E8 00000000       " # <1>  call %%next
    - "C70424 0A384300   " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret
    # .failure:
    # abs_jmp_hack 0x4335a5
    - "E8 00000000       " # <1>  call %%next
    - "C70424 A5354300   " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

  ExpHP.seasons-everywhere.autocollect-state-4:
    - "E8 [codecave:ExpHP.seasons-everywhere.is-bomb-or-release-autocollecting]" # call
    - "85C0              " # test    eax, eax
    - "740D              " # jz      .failure
    # .success:
    # abs_jmp_hack 0x43380a
    - "E8 00000000       " # <1>  call %%next
    - "C70424 0A384300   " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret
    # .failure:
    # abs_jmp_hack 0x4338c8
    - "E8 00000000       " # <1>  call %%next
    - "C70424 C8384300   " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

  ExpHP.seasons-everywhere.use-release-cancel-mode:
    # An explanation:
    # In TH17, the stack argument to the "cancel_bullets_in_radius" functions
    # looks like a boolean `is_cancel` because it only has the values 0 and 1,
    # but in fact it is more like a `cancel_mode` enum.
    # In TH16, bullets cancelled by releases had a "cancel mode" of 4,
    # which was checked to generate the season items. Given that the function that
    # generates the items is used by many different types of objects (not just the
    # Bullet struct), it seems best to continue this practice.
    #
    # We can't supply a cancel mode from ECL, so instead, releases are scripted
    # to supply negative radii.
    - "52                " # push    edx
    - "51                " # push    ecx
    - "83EC04            " # sub     esp, 0x4
    - "F30F110424        " # movss   [esp], xmm0  ; xmm0 has radius

    # if radius < 0, it's a release.
    # we'll operate on the sign bit using an integer register because it's easier.
    - "8B0C24            " # mov     ecx, [esp]  ; reinterpreting bits as integer
    - "85C9              " # test    ecx, ecx
    - "B801000000        " # mov     eax, 0x1
    - "BA04000000        " # mov     edx, 0x4
    - "0F4CC2            " # cmovl   eax, edx
    - "81E1FFFFFF7F      " # and     ecx, 0x7fffffff  ; take absolute value
    - "890C24            " # mov     [esp], ecx

    - "F30F100424        " # movss   xmm0, [esp]
    - "83C404            " # add     esp, 0x4
    - "59                " # pop     ecx
    - "5A                " # pop     edx

    - "50                " # push    eax  ; supply as stack arg to cancel_bullets_in_radius function

    # original code
    - "89F9              " # mov     ecx, edi
    - "F30F118598FBFFFF  " # movss   dword [ebp-0x468], xmm0
    # abs_jmp_hack  0x425cab
    - "E800000000        " # <1>  call %%next
    - "C70424AB5C4200    " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

  ExpHP.seasons-everywhere.impl-cancel-modes:
    - "83FA01            " # cmp     edx, 0x1
    - "7407              " # je      .mode_1
    - "83FA04            " # cmp     edx, 0x4
    - "740F              " # je      .mode_4
    - "EB5F              " # jmp     .mode_0

    # .mode_1:
    # abs_jmp_hack 0x419ca1
    - "E800000000        " # <1>  call %%next
    - "C70424A19C4100    " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

    # .mode_4:
    # Random direction +/- 10 degrees from straight up
    - "B968764B00        " # mov     ecx, SAFE_RNG
    - "B880284000        " # mov     eax, RANDF_NEG_1_TO_1
    - "FFD0              " # call    eax
    - "D80DF83A4A00      " # fmul    dword [FLOAT_PI_OVER_18]
    - "D95DFC            " # fstp    dword [ebp-0x4]
    - "F30F1045FC        " # movss   xmm0, dword [ebp-0x4]
    - "F30F5C05F43B4A00  " # subss   xmm0, dword [FLOAT_PI_OVER_2]

    - "6AFF              " # push    0xffffffff ; stack arg 20:  (unknown, new in TH17)
    - "51                " # push    ecx ; stack arg 1c:  (unused/optimized away)
    - "6A00              " # push    0x0 ; stack arg 18:  intangibility frames (ignored for PIV/season)
    - "83EC0C            " # sub     esp, 0xc
    - "C7442408CDCC0C40  " # mov     dword [esp+0x8], 0x400ccccd  ; stack arg 14: vel_norm
    - "F30F11442404      " # movss   dword [esp+0x4], xmm0        ; stack arg 10: vel_angle
    - "56                " # push    esi   ; stack arg 8: pos
    - "6A30              " # push    0x30  ; stack arg 4: item type
    - "8B0DB8764B00      " # mov     ecx, dword [ITEM_MANAGER_PTR]
    - "B840474300        " # mov     eax, ITMMGR_SPAWN_ITEM
    - "FFD0              " # call    eax
    # Make the item get autocollected once it stops moving.
    # (this field used to be an argument to spawn_item in TH16)
    # (this is implemented by another binhack; this field is an unused leftover from TH16)
    #
    # Given that all season items are already autocollected (or this flag is set) on any frame
    # that a release is active, this may seem unnecessary. AFAIK its only impact is during the
    # few frames that a season item has not had its ANM initialized yet.
    - "C780700C000001000000" # mov     dword [eax+en_force_autocollect], 1

    # .mode_0:
    # abs_jmp_hack 0x419ce5
    - "E800000000        " # <1>  call %%next
    - "C70424E59C4100    " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

  ExpHP.seasons-everywhere.item-noattract:
    # The original two checks
    - "83F804                    " #  cmp     eax, 0x4
    - "740C                      " #  je      .cannot_attract
    - "83F803                    " #  cmp     eax, 0x3
    - "7407                      " #  je      .cannot_attract
   
    # New check added by us
    - "83F809                    " #  cmp     eax, 0x9
    - "7402                      " #  je      .cannot_attract
   
    - "EB0D                      " #  jmp     .can_attract
   
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    # .cannot_attract:
    - "E800000000                " #  call    (next instruction)
    - "C7042498404300            " #  mov     dword [esp], 0x00434098
    - "C3                        " #  ret
   
    # workaround for [Rx] being broken  (side-effect-free absolute jump)
    # .can_attract:
    - "E800000000                " #  call    (next instruction)
    - "C70424E93F4300            " #  mov     dword [esp], 0x00433fe9
    - "C3                        " #  ret

  # void __thiscall EnemyFull::DropSeasonItems(Float3*)
  ExpHP.seasons-everywhere.impl-drop-season-items:
    - "55                " # push   ebp
    - "89E5              " # mov    ebp, esp
    - "57                " # push   edi
    - "56                " # push   esi

    # For some silly reason, TH16 computes the true season item bonus in
    # multiple places (at 0x41d600 in EnemyFull::die for killed enemies, and
    # god knows where for defeated spells/nonspells), overwriting the "max"
    # value stored in the EnemyDrop. Then in EnemyDrop::drop_ex it drops
    # that overwritten value.

    # However, it's much easier to just compute the bonus right before the
    # items are generated.  (My best guess as to why TH16 doesn't do this is
    # because EnemyDrop::drop_ex only has a pointer to the EnemyDrop and not
    # to the EnemyFull).

    # Get our patch's extra data associated with this enemy.
    - "8B8160570000      " # mov     eax, [ecx+efull_id]
    - "50                " # push    eax
    - "E8 [codecave:ExpHP.seasons-everywhere.find-enemy-ex-by-id]" # call
    - "89C7              " # mov     edi, eax

    # Find out item bonus based on time.
    - "89F9              " # mov     ecx, edi
    - "E8 [codecave:ExpHP.seasons-everywhere.ex-get-season-bonus]" # call
    - "89C6              " # mov     esi, eax

    - "85F6              " # test    esi, esi
    - "7E0C              " # jle     .loopend

    # .loop:
    - "8B4508            " # mov     eax, [ebp+0x8]
    - "50                " # push    eax
    - "E8 [codecave:ExpHP.seasons-everywhere.drop-one-item]" # call
    - "4E                " # dec     esi
    - "7FF4              " # jg      .loop

    # .loopend:
    - "C7473400000000    " # mov    dword [edi+ex_item_max], 0x0
    - "C7473800000000    " # mov    dword [edi+ex_item_min], 0x0

    - "5E                " # pop    esi
    - "5F                " # pop    edi
    - "89EC              " # mov    esp, ebp
    - "5D                " # pop    ebp
    - "C20400            " # ret    0x4

  # Factored out to make relative jumps in the caller more stable.
  # DWORD __thiscall EnemyEx::GetSeasonBonus()
  ExpHP.seasons-everywhere.ex-get-season-bonus:
    - "8B4120            " # mov     eax, dword [ecx+ex_bonus_timer+time_cur]
    - "85C0              " # test    eax, eax
    - "7F04              " # jg      .positivetime

    - "8B4138            " # mov     eax, dword [ecx+ex_item_min]
    - "C3                " # ret

    # .positivetime:
    # compute  min + (max - min) * (remaining_time / max_time)
    - "8B4134            " # mov     eax, dword [ecx+ex_item_max]
    - "2B4138            " # sub     eax, dword [ecx+ex_item_min]
    - "0FAF4120          " # imul    eax, dword [ecx+ex_bonus_timer+time_cur]
    - "99                " # cdq    ; I'm not sure why the original code did this...
    - "F77930            " # idiv    dword [ecx+ex_max_time]
    - "034138            " # add     eax, dword [ecx+ex_item_min]
    - "C3                " # ret

  # Factored out to make relative jumps in the caller more stable.
  # void __stdcall DropOneItem(Float3*);
  ExpHP.seasons-everywhere.drop-one-item:
    - "55                " # push   ebp
    - "89E5              " # mov    ebp, esp

    - "83EC24            " # sub    esp, 0x24   ; 0x20 arg size + 0x4 to match offsets in function
    - "C7442420FFFFFFFF  " # mov    dword [esp+0x20], -1     ; arg 20: (unknown, new in TH17)
    - "C744241C0DF00000  " # mov    dword [esp+0x1c], 0xf00d ; arg 1c: (unused/optimized away)
    - "C744241800000000  " # mov    dword [esp+0x18], 0      ; arg 18: intangibility frames (ignored for PIV/season)

    # velocity = uniform(0.2f, 2.1f)
    - "B968764B00        " # mov    ecx, SAFE_RNG
    - "B840284000        " # mov    eax, RANDF_0_TO_1
    - "FFD0              " # call   eax

    - "C704243333F33F    " # mov    dword [esp], 0x3ff33333  ; 1.9f
    - "D80C24            " # fmul   dword [esp]
    - "D805043B4A00      " # fadd   dword [FLOAT_0_POINT_2]
    - "D95C2414          " # fstp   dword [esp+0x14]  ; arg 14: vel_norm

    - "B968764B00        " # mov    ecx, SAFE_RNG
    - "E8 [codecave:ExpHP.seasons-everywhere.randf-minus-pi-to-pi]" # call
    - "D95C2410          " # fstp   dword [esp+0x10]  ; arg 10: vel_angle

    - "C744240C0DF00000  " # mov    dword [esp+0x0c], 0xf00d ; arg  c:  (unused/optimized away)
    - "8B4D08            " # mov    ecx, dword [ebp+0x8]
    - "894C2408          " # mov    dword [esp+0x08], ecx   ; arg 8: pos
    - "C744240430000000  " # mov    dword [esp+0x04], 0x30  ; arg 4: item type

    - "83C404            " # add    esp, 0x4  ; point esp to first arg
    - "8B0DB8764B00      " # mov    ecx, [ITEM_MANAGER_PTR]
    - "B840474300        " # mov    eax, ITMMGR_SPAWN_ITEM
    - "FFD0              " # call   eax

    - "89EC              " # mov    esp, ebp
    - "5D                " # pop    ebp
    - "C20400            " # ret    0x4

  ExpHP.seasons-everywhere.drop-season-items:
    - "8B4508            " # mov    eax, [ebp+0x8]  ; Float3* pos arg
    - "50                " # push   eax

    # Recover the EnemyFull.
    - "8B4DF8            " # mov    ecx, [ebp-0x8]  ; EnemyDrop* in local var
    - "8D8970C0FFFF      " # lea    ecx, [ecx-en_drop]
    - "8D89F4EDFFFF      " # lea    ecx, [ecx-efull_enemy]

    - "E8 [codecave:ExpHP.seasons-everywhere.impl-drop-season-items]" # call

    # original code
    - "6888000000        " # push    0x88
    # abs_jmp_hack 0x41da3a
    - "E800000000        " # <1>  call %%next
    - "C704243ADA4100    " # <1>  mov dword [esp], %1
    - "C3                " # <1>  ret

  # Wrapper around ECLPlus' IntVarSwitch that preserves the volatile ecx, edx, and xmm registers.
  ExpHP.seasons-everywhere.eclplus-int-switch:
    # Prologue that saves volatile registers
    - "55                    " # push   ebp
    - "89 E5                 " # mov    ebp,esp
    - "83 e4f0               " # and    esp,0xfffffff0   # align for movaps
    - "81 ec80000000         " # sub    esp,0x80
    - "0f290424              " # movaps XMMWORD PTR [esp],xmm0
    - "0f294c2410            " # movaps XMMWORD PTR [esp+0x10],xmm1
    - "0f29542420            " # movaps XMMWORD PTR [esp+0x20],xmm2
    - "0f295c2430            " # movaps XMMWORD PTR [esp+0x30],xmm3
    - "0f29642440            " # movaps XMMWORD PTR [esp+0x40],xmm4
    - "0f296c2450            " # movaps XMMWORD PTR [esp+0x50],xmm5
    - "0f29742460            " # movaps XMMWORD PTR [esp+0x60],xmm6
    - "0f297c2470            " # movaps XMMWORD PTR [esp+0x70],xmm7
    - "51                    " # push   ecx
    - "52                    " # push   edx

    # Forward args to ECLPlus
    - "ff 75 10              " # push   DWORD PTR [ebp+0x10]
    - "ff 75 0c              " # push   DWORD PTR [ebp+0xc]
    - "ff 75 08              " # push   DWORD PTR [ebp+0x8]
    - "FF15 E49F4900         " # call dword [0x499FE4]   # pointer to ECLplus.dll+IntVarSwitch

    # Epilogue that restores volatile registers
    - "5a                    " # pop    edx
    - "59                    " # pop    ecx
    - "0f280424              " # movaps xmm0,XMMWORD PTR [esp]
    - "0f284c2410            " # movaps xmm1,XMMWORD PTR [esp+0x10]
    - "0f28542420            " # movaps xmm2,XMMWORD PTR [esp+0x20]
    - "0f285c2430            " # movaps xmm3,XMMWORD PTR [esp+0x30]
    - "0f28642440            " # movaps xmm4,XMMWORD PTR [esp+0x40]
    - "0f286c2450            " # movaps xmm5,XMMWORD PTR [esp+0x50]
    - "0f28742460            " # movaps xmm6,XMMWORD PTR [esp+0x60]
    - "0f287c2470            " # movaps xmm7,XMMWORD PTR [esp+0x70]
    - "89 EC                 " # mov    esp,ebp
    - "5D                    " # pop    ebp

    - "C2 0c00               " # ret    0xc

  #==============================================
  # Utils

  # ecx is a node not in any list. (this is checked)
  # [esp+0x4] is a list head. (this is checked)
  # Makes ecx into a list head, and returns it.
  ExpHP.seasons-everywhere.zunlist-prepend:
    - "8B542404                  " # mov    edx, [esp+0x4]
    - "8B4208                    " # mov    eax, [edx+0x8]  ; head.prev
    - "0B4104                    " # or     eax, [ecx+0x4]  ; this.next
    - "0B4108                    " # or     eax, [ecx+0x8]  ; this.prev
    - "85C0                      " # test   eax, eax        ; are any nonnull?
    - "750B                      " # jnz    .error
    
    - "895104                    " # mov    [ecx+0x4], edx  ; this.next = head
    - "894A08                    " # mov    [edx+0x8], ecx  ; head.prev = this
    - "89C8                      " # mov    eax, ecx
    - "C20400                    " # ret    0x4
    # .error:
    - "0F0B                      " # ud2

  # ecx is a node not in any list. (this is checked)
  # [esp+0x4] is any node.
  ExpHP.seasons-everywhere.zunlist-insert-after:
    - "8B542404                  " # mov    edx, [esp+0x4]
    - "8B4104                    " # mov    eax, [ecx+l_next]  ; this.next
    - "0B4108                    " # or     eax, [ecx+l_prev]  ; this.prev
    - "85C0                      " # test   eax, eax        ; are any nonnull?
    - "7518                      " # jnz    .error
    
    - "8B4204                    " # mov    eax, [edx+l_next]
    - "894104                    " # mov    [ecx+l_next], eax  ; this.next = node.next
    - "85C0                      " # test   eax, eax
    - "7403                      " # jz     .no_next
    - "894808                    " # mov    [eax+l_prev], ecx  ; node.next.prev = this
    # .no_next:
    
    - "895108                    " # mov    [ecx+l_prev], edx  ; this.prev = node
    - "894A04                    " # mov    [edx+l_next], ecx  ; node.next = this
    - "89C8                      " # mov    eax, ecx
    - "C20400                    " # ret    0x4
    # .error:
    - "0F0B                      " # ud2
  
  # Removes the node in ecx from its list.
  # Returns ecx.
  ExpHP.seasons-everywhere.zunlist-remove-node:
    - "8B4104                    " # mov    eax, [ecx+l_next]  ; this.next
    - "8B5108                    " # mov    edx, [ecx+l_prev]  ; this.prev
    
    - "85C0                      " # test   eax, eax
    - "7403                      " # jz     .no_next
    - "895008                    " # mov    [eax+l_prev], edx  ; next.prev = this.prev
    # .no_next:
    
    - "85D2                      " # test   edx, edx
    - "7403                      " # jz     .no_prev
    - "894204                    " # mov    [edx+l_next], eax  ; prev.next = this.next
    # .no_prev:
    
    - "C7410400000000            " # mov    DWORD [ecx+l_next], 0x0  ; this.prev = 0
    - "C7410800000000            " # mov    DWORD [ecx+l_prev], 0x0  ; this.next = 0
    - "89C8                      " # mov    eax, ecx
    - "C3                        " # ret

  # void* __stdcall Calloc(size)
  ExpHP.seasons-everywhere.calloc:
    - "55                " # push   ebp
    - "89E5              " # mov    ebp, esp
    - "57                " # push   edi

    - "8B4508            " # mov    eax, [ebp+0x8]
    - "50                " # push   eax
    - "B850B24700        " # mov    eax, MALLOC
    - "FFD0              " # call   eax
    - "89C7              " # mov    edi, eax

    - "8B4508            " # mov    eax, [ebp+0x8]
    - "50                " # push   eax
    - "6A00              " # push   dword 0x0
    - "57                " # push   edi
    - "B860CE4700        " # mov    eax, MEMSET
    - "FFD0              " # call   eax

    - "89F8              " # mov    eax, edi
    - "5F                " # pop    edi

    - "89EC              " # mov    esp, ebp
    - "5D                " # pop    ebp
    - "C20400            " # ret    4

  # This is th16.exe+0x402cf0, which doesn't exist in TH17.
  #
  # Much like the TH16 function, the ABI is that of returning a long double,
  # but it only has the precision of a float.
  #
  # long double __thiscall Rng::randf_minus_pi_to_pi()
  ExpHP.seasons-everywhere.randf-minus-pi-to-pi:
    - "55                " # push     ebp
    - "89E5              " # mov      ebp, esp
    - "51                " # push     ecx
    - "9B                " # fwait
    - "DBE3              " # fninit
    - "B8B0274000        " # mov      eax, RAND_DWORD
    - "FFD0              " # call     eax
    - "660F6EC0          " # movd     xmm0, eax

    # (ebp-0x4 is the space in the red zone left behind by
    #  the arg to rand_int, used as scratch)
    #
    # This is the float value 683565248.0, which is 2**32 / 2PI.
    - "C745FC83F9224E    " # mov      dword [ebp-0x4], 0x4e22f983

    # These three lines together are a cast from uint32_t to double
    - "F30FE6C0          " # cvtdq2pd xmm0, xmm0
    - "C1E81F            " # shr      eax, 0x1f
    - "F20F5804C5303F4A00" # addsd    xmm0, qword [eax*8+0x4a3f30]

    # Map into range from -PI to PI
    - "660F5AC0          " # cvtpd2ps xmm0, xmm0
    - "F30F5E45FC        " # divss    xmm0, dword [ebp-0x4]
    - "F30F5C0588454900  " # subss    xmm0, dword [FLOAT_PI]

    # Return in the FPU for seemingly no good reason.
    - "F30F1145FC        " # movss    dword [ebp-0x4], xmm0
    - "D945FC            " # fld      dword [ebp-0x4]
    - "89EC              " # mov      esp, ebp
    - "5D                " # pop      ebp
    - "C3                " # retn
