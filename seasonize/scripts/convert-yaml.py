#!/usr/bin/env python3

import re
import sys

def main():
    import argparse
    import json
    from ruamel.yaml import YAML
    from functools import reduce
    yaml = YAML(typ='safe')

    parser = argparse.ArgumentParser()
    parser.add_argument('INPUT', nargs='+', help='yaml files')
    parser.add_argument('-o', '--output', required=True, help='output json file')
    args = parser.parse_args()

    def load_file(fname):
        with open(fname) as f:
            return yaml.load(f)

    y = reduce(merge_json, [load_file(fname) for fname in args.INPUT])

    process_local_caves(y)
    if 'binhacks' in y:
        for binhack in y['binhacks'].values():
            if 'code' in binhack:
                binhack['code'] = concat_code_sequences(binhack['code'])
            if 'expected' in binhack:
                binhack['expected'] = concat_code_sequences(binhack['expected'])
    if 'codecaves' in y:
        for cave_key in y['codecaves']:
            if cave_key != 'protection':
                y['codecaves'][cave_key] = concat_code_sequences(y['codecaves'][cave_key])

    # take advantage of python 3.7's insertion-order dicts to put this comment at the top
    out = {'COMMENT': 'This file is autogenerated.  Please do not edit it directly.  See the convert-yaml.py script.'}
    out.update(y)

    with open(args.output, 'w') as f:
        json.dump(out, f, indent=4)

def merge_json(a, b, path=None):
    if path is None:
        path = []

    if isinstance(a, dict) or isinstance(b, dict):
        out = {}
        if not (isinstance(a, dict) and isinstance(b, dict)):
            die(f'at key {repr(path)}: cannot merge object with non-object')
        for key in a:
            if key in b:
                out[key] = merge_json(a[key], b[key])
            else:
                out[key] = a[key]

        for key in b:
            if key not in a:
                out[key] = b[key]

        return out
    else:
        return b

def process_local_caves(json):
    binhacks = json.get('binhacks', {})
    if 'codecaves' not in json:
        json['codecaves'] = {}
    codecaves = json['codecaves']

    for key, binhack in binhacks.items():
        if 'codecave' not in binhack:
            continue

        # move to codecaves
        cave_asm = binhack.pop('codecave')
        cave_name = f'of({key})'
        codecaves[cave_name] = cave_asm

        # insert a jump to the codecave
        assert 'code' not in binhack
        expected_len = get_code_len(binhack['expected'])
        if expected_len < 10:
            die(f'in {repr(key)}: expected code too short to insert jump')

        # jmp [cave] followed by int3's
        binhack['code'] = [f'E9 [codecave:{cave_name}]']
        if expected_len > 10:
            binhack['code'].append('C' * (expected_len - 10))

    for key, binhack in binhacks.items():
        if 'expected' in binhack:
            if get_code_len(binhack['expected']) != get_code_len(binhack['code']):
                die(f'in {repr(key)}: expected/actual code length mismatch')

def get_code_len(code):
    """ Get number of hexadecimal units in code. (2x number of bytes) """
    code = concat_code_sequences(code)
    code = re.sub(r'\[[^\]]+\]', '00000000', code)
    code = re.sub(r'<[^>]+>', '00000000', code)
    code = ''.join([c for c in code if c in '0123456789abcdefABCDEF'])
    return len(code)

def concat_code_sequences(val):
    """ Post-process a code field into a string, allowing it to be initially
    written as a sequence of strings. (which provides room to write comments) """
    if isinstance(val, list):
        return ' // '.join(x.strip() for x in val)
    return val

def die(*args):
    print('FATAL:', *args, file=sys.stderr)
    sys.exit(1)

if __name__ == '__main__':
    main()
